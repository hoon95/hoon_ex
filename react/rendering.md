### $Rendering(렌더링) : 화면에 표시할 웹 페이지를 만드는 과정

[[Rendering] SSR & CSR](https://headf1rst.github.io/front_end/SSR-CSR/)

<aside>
💡 CSR(Client Side Rendering) : 렌더링이 클라이언트 쪽에서 일어남
- 서버는 요청을 받으면 클라이언트에 HTML, JS를 보내주고 클라이언트는 그것을 받아 렌더링을 시작함

</aside>

1. 클라이언트가 서버에 페이지를 요청
2. 기본 HTML, CSS, JavaScript 파일을 클라이언트에 반환
3. 브라우저에서 기본 레이아웃 생성 및 표시
4. 페이지 로딩 후 클라이언트는 서버에 데이터(콘텐츠) 요청
5. 클라이언트는 서버로부터 받은 데이터를 통해 동적 DOM 생성 및 페이지 업데이트

<aside>
💡 요청한 데이터를 클라이언트에서 받아와서 그 데이터를 통해 동적으로 페이지를 업데이트 한다.
→ 이러한 과정이 클라이언트에서 일어나기 때문에 클라이언트 사이드 렌더링(CSR)이다

</aside>

### 장점

- 빠른 상호작용 : 초기 페이지 로딩 이후부터는 서버에 추가 요청을 통해 빠른 상호작용 가능
- 사용자 경험 : 동적으로 업데이트 되어 페이지가 새로고침 되지 않아도 된다(사용자 경험 개선)
- 서버 부하 감소 : 클라이언트에서 렌더링이 일어나므로 서버의 부하가 줄어든다(서버는 초기 요청 시 필요한 기본 자원만 전송)

### 단점

- 로딩 속도가 느림 : 초기에 페이지를 구성하는 모든 자원을 전송함
- 검색 엔진 최적화(SEO)의 어려움 : 초기 로드 시 빈 HTML 파일과 로직이 담겨있는 JavaScript를 가져오는데, 검색 엔진은 JavaScript를 실행하지 못할 수 있음. 페이지에 대한 정보를 담기 힘들어 노출 빈도가 줄어들 수 있음. 이는 수익성 악화로 이어짐(Next.js의 등장과 이어짐)
- 크롤링 : 마찬가지로 크롤러는 동적으로 생성된 콘텐츠를 인식하지 못할 수 있음
- 유지보수의 어려움 : JavaScript의 코드 양이 늘어나 유지보수가 어려울 수 있음

<aside>
💡 SSR(Server Side Rendering) : 렌더링이 서버 쪽에서 일어남

</aside>

1. 클라이언트가 서버에 페이지를 요청
2. 서버에서 페이지를 렌더링
3. 렌더링 된 페이지를 클라이언트에 전송
4. 전송받은 HTML, JavaScript를 다운로드하여 사용자에게 표시

<aside>
💡 요청한 페이지를 서버에서 초기에 렌더링하고 클라이언트에게 반환한다. 이후 클라이언트는 필요한 경우 서버에 추가적인 데이터를 요청하여 받아와서 동적으로 페이지를 업데이트한다.
→ 이러한 과정에서 초기 렌더링은 서버에서 이루어지기 때문에 서버 사이드 렌더링(SSR)이라고 한다. 추가로 받아온 데이터를 이용해 클라이언트 측에서 동적 업데이트가 가능하다.

</aside>

> CSR과 SSR은 초기 로딩 과정에서 차이를 보인다. 페이지가 로딩 된 후 클라이언트에서 추가 요청이 필요한 경우 CSR과 SSR 둘 다 동적으로 페이지를 업데이트하고 상호 작용한다.

>→ 초기 로딩 방식과 SEO 최적화에 따른 차이가 있다

> **어떤 방식이 좋을까?**

>→ 애플리케이션의 특성에 따라 선택할 것(정답은 없음)
ex 1. 대규모 실시간 애플리케이션 : CSR이 적합
ex 2. 검색어에 따라 나타나는 결과(대화형 컴포넌트) : CSR이 적합
ex 3. 검색 노출이 중요한 경우 : SSR이 적합
ex 4. SNS 미리보기 : SSR이 적합(HTML이 서버에서 생성되기 때문)